<?xml version="1.0" encoding="UTF-8"?>
<!--
    ########### SVN repository information ###################
    # $LastChangedDate$
    # $LastChangedBy$
    # $LastChangedRevision$
    # $HeadURL$
    ########### SVN repository information ###################

    Usage: xsltproc netvarconfig2db.xsl netvarconfig.xml > epics_records.db
	
	@file netvarconfig2db.xsl Process a NINetVar XML configuration file to generate EPICS DB records
	@author Freddie Akeroyd, STFC ISIS Facility, UK
	
-->
<xsl:stylesheet
    version="1.0"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:nv="http://epics.isis.rl.ac.uk/NiNetVarConfig/1.0">
    
    <xsl:output method="text" indent="yes" />

   <xsl:template match="/nv:ninetvar">
# Initially generated by $Id$
# 
# auto-generated EPICS records specify an asyn port "nsv", but this can be changed - it just needs
# to match the first argument of the relevant NINetVarConfigure() command in the IOC st.cmd 
# 
      <xsl:apply-templates select="nv:section" />
	</xsl:template>
	
   <xsl:template match="nv:section">
      <xsl:variable name="section_name" select="@name" />
# 
# Definitions from configSection "<xsl:value-of select="$section_name"/>" in XML input file
#
#     NINetVarConfigure("nsv", "<xsl:value-of select="$section_name"/>", "/path/to/ninetvarconfig.xml", 100)
# 
      <xsl:apply-templates select="nv:param" />
	</xsl:template>
   
   <xsl:template match="nv:param">
      <xsl:variable name="asyn_param" select="@name" />
      <xsl:variable name="netvar" select="@netvar" />
      <xsl:variable name="field" select="@field" />
      <xsl:variable name="asyn_type">
	    <xsl:call-template name="convertToAsynType">
	      <xsl:with-param name="vartype" select="@type" />
	    </xsl:call-template>
	  </xsl:variable>
      <xsl:variable name="nsv_desc">NSV '<xsl:value-of select="$netvar"/>'<xsl:if test="$field">[<xsl:value-of select="$field"/>]</xsl:if></xsl:variable>
      <xsl:variable name="nsv_comment">Network shared variable "<xsl:value-of select="$netvar"/>" <xsl:if test="$field"> struct field index <xsl:value-of select="$field"/></xsl:if></xsl:variable>

<xsl:choose>
<xsl:when test="@type = 'string'">
## Creating both stringout/stringin and waveform records for <xsl:value-of select="$nsv_desc"/>
## EPICS strings are restricted to 40 characters in length, if your strings are
## longer than this choose the character waveform records and adjust NELM if necessary

# Read <xsl:value-of select="$nsv_comment"/>
record(stringin, "$(P)<xsl:value-of select="$asyn_param"/>_RBV")
{
    field(DESC, "<xsl:value-of select="$nsv_desc"/>")
    field(DTYP, "<xsl:value-of select="$asyn_type"/>Read")
    field(INP,  "@asyn(nsv,0,0)<xsl:value-of select="$asyn_param"/>")
    field(SCAN, "I/O Intr")
}

# Write <xsl:value-of select="$nsv_comment"/>
record(stringout, "$(P)<xsl:value-of select="$asyn_param"/>")
{
    field(DESC, "<xsl:value-of select="$nsv_desc"/>")
    field(DTYP, "<xsl:value-of select="$asyn_type"/>Write")
    field(OUT,  "@asyn(nsv,0,0)<xsl:value-of select="$asyn_param"/>")
}

# Read <xsl:value-of select="$nsv_comment"/>
record(waveform, "$(P)<xsl:value-of select="$asyn_param"/>WF_RBV")
{
    field(DESC, "<xsl:value-of select="$nsv_desc"/>")
    field(DTYP, "<xsl:value-of select="$asyn_type"/>Read")
	field(FTVL, "CHAR")
	field(NELM, 256)
    field(INP,  "@asyn(nsv,0,0)<xsl:value-of select="$asyn_param"/>")
    field(SCAN, "I/O Intr")
}

# Write <xsl:value-of select="$nsv_comment"/>
record(waveform, "$(P)<xsl:value-of select="$asyn_param"/>WF")
{
    field(DESC, "<xsl:value-of select="$nsv_desc"/>")
    field(DTYP, "<xsl:value-of select="$asyn_type"/>Write")
	field(FTVL, "CHAR")
	field(NELM, 256)
    field(INP,  "@asyn(nsv,0,0)<xsl:value-of select="$asyn_param"/>")
}
</xsl:when>	
<xsl:when test="@type = 'int32'">
# Read <xsl:value-of select="$nsv_comment"/>
record(longin, "$(P)<xsl:value-of select="$asyn_param"/>_RBV")
{
    field(DESC, "<xsl:value-of select="$nsv_desc"/>")
    field(DTYP, "<xsl:value-of select="$asyn_type"/>")
    field(INP,  "@asyn(nsv,0,0)<xsl:value-of select="$asyn_param"/>")
    field(SCAN, "I/O Intr")
}

# Write <xsl:value-of select="$nsv_comment"/>
record(longout, "$(P)<xsl:value-of select="$asyn_param"/>")
{
    field(DESC, "<xsl:value-of select="$nsv_desc"/>")
    field(DTYP, "<xsl:value-of select="$asyn_type"/>")
    field(OUT,  "@asyn(nsv,0,0)<xsl:value-of select="$asyn_param"/>")
}

</xsl:when>
<xsl:when test="@type = 'float64'">
# Read <xsl:value-of select="$nsv_comment"/>
record(ai, "$(P)<xsl:value-of select="$asyn_param"/>_RBV")
{
    field(DESC, "<xsl:value-of select="$nsv_desc"/>")
    field(DTYP, "<xsl:value-of select="$asyn_type"/>")
    field(INP,  "@asyn(nsv,0,0)<xsl:value-of select="$asyn_param"/>")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

# Write <xsl:value-of select="$nsv_comment"/>
record(ao, "$(P)<xsl:value-of select="$asyn_param"/>")
{
    field(DESC, "<xsl:value-of select="$nsv_desc"/>")
    field(DTYP, "<xsl:value-of select="$asyn_type"/>")
    field(OUT,  "@asyn(nsv,0,0)<xsl:value-of select="$asyn_param"/>")
    field(PREC, "3")
}

</xsl:when>
<xsl:when test="@type = 'float64array'">
# Read <xsl:value-of select="$nsv_comment"/>
record(waveform, "$(P)<xsl:value-of select="$asyn_param"/>_RBV")
{
    field(DESC, "<xsl:value-of select="$nsv_desc"/>")
    field(DTYP, "<xsl:value-of select="$asyn_type"/>In")
	field(FTVL, "DOUBLE")
	field(NELM, 1000)
    field(INP,  "@asyn(nsv,0,0)<xsl:value-of select="$asyn_param"/>")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

# Write <xsl:value-of select="$nsv_comment"/>
record(waveform, "$(P)<xsl:value-of select="$asyn_param"/>")
{
    field(DESC, "<xsl:value-of select="$nsv_desc"/>")
    field(DTYP, "<xsl:value-of select="$asyn_type"/>Out")
	field(FTVL, "DOUBLE")
	field(NELM, 1000)
    field(INP,  "@asyn(nsv,0,0)<xsl:value-of select="$asyn_param"/>")
    field(PREC, "3")
}

</xsl:when>
<xsl:when test="@type = 'int32array'">
# Read <xsl:value-of select="$nsv_comment"/>
record(waveform, "$(P)<xsl:value-of select="$asyn_param"/>_RBV")
{
    field(DESC, "<xsl:value-of select="$nsv_desc"/>")
    field(DTYP, "<xsl:value-of select="$asyn_type"/>In")
	field(FTVL, "LONG")
	field(NELM, 1000)
    field(INP,  "@asyn(nsv,0,0)<xsl:value-of select="$asyn_param"/>")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

# Write <xsl:value-of select="$nsv_comment"/>
record(waveform, "$(P)<xsl:value-of select="$asyn_param"/>")
{
    field(DESC, "<xsl:value-of select="$nsv_desc"/>")
    field(DTYP, "<xsl:value-of select="$asyn_type"/>Out")
	field(FTVL, "LONG")
	field(NELM, 1000)
    field(INP,  "@asyn(nsv,0,0)<xsl:value-of select="$asyn_param"/>")
}

</xsl:when>
<xsl:when test="@type = 'boolean'">
    <xsl:variable name="zname">
        <xsl:call-template name="formatMBString"><xsl:with-param name="value" select="@fval"></xsl:with-param></xsl:call-template>
    </xsl:variable>
    <xsl:variable name="oname">
        <xsl:call-template name="formatMBString"><xsl:with-param name="value" select="@tval"></xsl:with-param></xsl:call-template>
    </xsl:variable>
# Read <xsl:value-of select="$nsv_comment"/>
record(bi, "$(P)<xsl:value-of select="$asyn_param"/>_RBV")
{
    field(DESC, "<xsl:value-of select="$nsv_desc"/>")
    field(DTYP, "<xsl:value-of select="$asyn_type"/>")
    field(INP,  "@asyn(nsv,0,0)<xsl:value-of select="$asyn_param"/>")
    field(SCAN, "I/O Intr")
    field(ZNAM, "<xsl:value-of select="$zname"/>")
    field(ONAM, "<xsl:value-of select="$oname"/>")
}

# Write <xsl:value-of select="$nsv_comment"/>
record(bo, "$(P)<xsl:value-of select="$asyn_param"/>")
{
    field(DESC, "<xsl:value-of select="$nsv_desc"/>")
    field(DTYP, "<xsl:value-of select="$asyn_type"/>")
    field(OUT,  "@asyn(nsv,0,0)<xsl:value-of select="$asyn_param"/>")
    field(ZNAM, "<xsl:value-of select="$zname"/>")
    field(ONAM, "<xsl:value-of select="$oname"/>")
}

</xsl:when>
<xsl:otherwise>
#
# ERROR type "<xsl:value-of select="@type"/>" for "<xsl:value-of select="$netvar"/>" is invalid
#

</xsl:otherwise>
</xsl:choose>

    </xsl:template>

    <!-- record length in mbbi/mbbo is 26 chars = 25 + \0 -->
    <xsl:template name="formatMBString">  
        <xsl:param name="value" />
        <xsl:choose>
            <xsl:when test="string-length($value) &lt; 26">
                <xsl:value-of select="$value"/>
            </xsl:when>
            <xsl:when test="string-length(normalize-space($value)) &lt; 26">
                <xsl:value-of select="normalize-space($value)"/>
            </xsl:when>
            <xsl:when test="string-length(translate($value, ' ', '')) &lt; 26">
                <xsl:value-of select="translate($value, ' ', '')"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="substring(translate($value, ' ', ''), 1, 25)"/>               
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    

    <xsl:template name="allmb">
       <xsl:call-template name="mb"><xsl:with-param name="prefix">ZR</xsl:with-param><xsl:with-param name="pos">1</xsl:with-param></xsl:call-template>
       <xsl:call-template name="mb"><xsl:with-param name="prefix">ON</xsl:with-param><xsl:with-param name="pos">2</xsl:with-param></xsl:call-template>
       <xsl:call-template name="mb"><xsl:with-param name="prefix">TW</xsl:with-param><xsl:with-param name="pos">3</xsl:with-param></xsl:call-template>
       <xsl:call-template name="mb"><xsl:with-param name="prefix">TH</xsl:with-param><xsl:with-param name="pos">4</xsl:with-param></xsl:call-template>
       <xsl:call-template name="mb"><xsl:with-param name="prefix">FR</xsl:with-param><xsl:with-param name="pos">5</xsl:with-param></xsl:call-template>
       <xsl:call-template name="mb"><xsl:with-param name="prefix">FV</xsl:with-param><xsl:with-param name="pos">6</xsl:with-param></xsl:call-template>
       <xsl:call-template name="mb"><xsl:with-param name="prefix">SX</xsl:with-param><xsl:with-param name="pos">7</xsl:with-param></xsl:call-template>
       <xsl:call-template name="mb"><xsl:with-param name="prefix">SV</xsl:with-param><xsl:with-param name="pos">8</xsl:with-param></xsl:call-template>
       <xsl:call-template name="mb"><xsl:with-param name="prefix">EI</xsl:with-param><xsl:with-param name="pos">9</xsl:with-param></xsl:call-template>
       <xsl:call-template name="mb"><xsl:with-param name="prefix">NI</xsl:with-param><xsl:with-param name="pos">10</xsl:with-param></xsl:call-template>
       <xsl:call-template name="mb"><xsl:with-param name="prefix">TE</xsl:with-param><xsl:with-param name="pos">11</xsl:with-param></xsl:call-template>
       <xsl:call-template name="mb"><xsl:with-param name="prefix">EL</xsl:with-param><xsl:with-param name="pos">12</xsl:with-param></xsl:call-template>
       <xsl:call-template name="mb"><xsl:with-param name="prefix">TV</xsl:with-param><xsl:with-param name="pos">13</xsl:with-param></xsl:call-template>
       <xsl:call-template name="mb"><xsl:with-param name="prefix">TT</xsl:with-param><xsl:with-param name="pos">14</xsl:with-param></xsl:call-template>
       <xsl:call-template name="mb"><xsl:with-param name="prefix">FT</xsl:with-param><xsl:with-param name="pos">15</xsl:with-param></xsl:call-template>
       <xsl:call-template name="mb"><xsl:with-param name="prefix">FF</xsl:with-param><xsl:with-param name="pos">16</xsl:with-param></xsl:call-template>
    </xsl:template>

    <xsl:template name="mb">
        <xsl:param name="prefix" />
        <xsl:param name="pos" />
        <xsl:variable name="node" select="nv:items/nv:item[position()=$pos]" />
        <xsl:if test="$node">
            <xsl:variable name="tname">
                <xsl:call-template name="formatMBString"><xsl:with-param name="value" select="$node/@name"></xsl:with-param></xsl:call-template>
            </xsl:variable>
    field(<xsl:value-of select="$prefix"/>VL, <xsl:value-of select="$node/@value"/>)
    field(<xsl:value-of select="$prefix"/>ST, "<xsl:value-of select="$tname"/>")
        </xsl:if>
    </xsl:template>

    <xsl:template name="convertToAsynType">
	<xsl:param name="vartype" />
	<xsl:choose>
        <xsl:when test="$vartype = 'int32'">asynInt32</xsl:when>
        <xsl:when test="$vartype = 'boolean'">asynInt32</xsl:when>
        <xsl:when test="$vartype = 'float64'">asynFloat64</xsl:when>
        <xsl:when test="$vartype = 'string'">asynOctet</xsl:when>
        <xsl:when test="$vartype = 'float64array'">asynFloat64Array</xsl:when>
        <xsl:when test="$vartype = 'float32array'">asynFloat32Array</xsl:when>
        <xsl:when test="$vartype = 'int32array'">asynInt32Array</xsl:when>
        <xsl:when test="$vartype = 'int16array'">asynInt16Array</xsl:when>
        <xsl:when test="$vartype = 'int8array'">asynInt8Array</xsl:when>
		<xsl:otherwise>invalid</xsl:otherwise>
	</xsl:choose>
	
</xsl:template>

</xsl:stylesheet>
